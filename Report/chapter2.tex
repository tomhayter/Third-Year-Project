\chapter{Background}

\section{Diets}

After suffering from the COVID-19 pandemic, restaurants are keen to get as much business as possible. To do this, they need to cater to all customers and all dietary requirements. To achieve that, they need to allow customers to easily deduce which dishes are suitable for them.

Almost 30\% of adults in the UK have some sort of vegetarian-based diet \cite{vege_2022}, and the percentage is greater in the younger generations than the older ones. With an increasing concern about the environmental, ethical and health impacts of the food that we eat - people are looking at reducing and removing meat from their diets (Flexitarian or Vegetarian), or removing all animal products completely (Vegan).

On top of this, 8\% of children and 6\% of adults have a food-based allergy \cite{sicherer_sampson_2017}. The most common food allergies are cow's milk, eggs, peanuts, soybeans, wheat, fish, shellfish and tree nuts \cite{allergies_west_2023}. Allergic reactions can vary from mild to severe, and therefore, it is important that a restaurant is able to offer allergen information about their dishes. Furthermore, while Coeliac disease is not an allergy but a autoimmune disease, those who suffer from the disease want to avoid foods that contain gluten which is a similar problem to allergies.

With 63\% of people in the UK stating they have some religion \cite{religion_ons_census_2021}, and 84\% of the population worldwide \cite{hackett_grim_2012}, it is vital to consider religious dietary requirements. I have used this guide \cite{guidance_on_foods_for_religious_faiths_2009} to understand what dietary requirements different religions have. At least 45\% of the global population will have a dietary requirement purely based on their religous belief, which makes it essential that they are considered by restaurants. While some religions simply follow or encourage vegetarianism or veganism (such as Buddhism), others are more complex. Hinduism and Sikhism will specifically not eat beef or beef products. Furthermore, Muslims, Jews, and Rastafarians will not eat pork or pork products, with the former two not eating shellfish either. Therefore, specfic measures should be taken to ensure that these customers can determine which dishes are suitable for them.

In addition to specific ingredients, there are other religious beliefs concerning food. Muslims are only permitted to eat Halal (permissable) foods, or foods that are not Haram (forbidden). Halal meats must come from an animal that has been slaughtered in a specific way according to Islamic Law (Shari'ah) \cite{halal_monitoring_committee_2018}. The animal must be alive and healthy at the time of slaughter, and after invoking the name of Allah on the animal, at least three of the Trachea, Oesophagus and both Jugular Viens must be severed. In Judaism, followers may only eat Kosher foods \cite{kosher_2023} ; foods that conform to \textit{kashrut} (Jewish dietary law). This specifies that they must not eat dairy and meat products together, and the two should not be prepared together either to avoid cross-contamination. Meat should also be sourced from an animal that has been slaughtered in a specific way.

Both Halal and Kosher foods do not solely revolve around what ingredients are in a dish, but also how that dish has been prepared. It should also be noted that not all religions are strict. Some religious followers are stricter with diets than others, so there is not one single catch-all dietary requirement for a religion.


\section{Ontologies}

While researching ontologies, I constantly referred to the \textit{``Pizza Tutorial''} \cite{pizza_tutorial_site}. It provides a comprehensive understanding of ontologies and how they work, while also providing examples and a tutorial to follow along with. In this section, I will represent classes in bold such as \textbf{ClassA} and properties in italic such as \textit{propertyA}. Axioms will be represented in quotation marks and italics, such as \textit{``ClassA propertyA ClassB''}

An ontology is a knowledge-based way of storing information. They are stored in a \textit{.owl} file, which is similar to Extensible Markup Language (XML). It works in a object oriented kind-of way, where every thing is a class. Ontologies make use of the concept of inheritance, so classes can have subclasses where the subclass \textit{``is a''} superclass. For example, the class \textbf{House} could be a subclass of \textbf{Building}, and could have \textbf{Mansion}, \textbf{Bungalow} and \textbf{Cottage} as it's subclasses. This works because a house \textit{``is a''} building and a cottage \textit{``is a''} house. Everything that holds true for a superclass also holds true for all the subclasses. In an ontology, every class is a subclass of \textbf{owl:Thing}. It is convention to name a subclass with a suffix to make it clear what it is a subclass of (other than when creating a subclass of \textbf{owl:Thing}). In the previous example, all subclasses of \textbf{House} would have the suffix \textit{``House''} (e.g. \textbf{CottageHouse} and \textbf{BungalowHouse}) to differentiate them from anything else that could have the same name. For example, having one class called \textbf{Cottage} could lead to ambiguity between the building and the type of cheese - if both happened to be stored in the same ontology. 

Ontologies contain facts, properties and rules, and uses those rules and properties to infer more facts. There is a tool called a reasoner which infers these facts. While many are available, I have used Hermit \cite{hermit} as it is the most up to date.

\subsection{Object and Data Properties}

There are two kinds of properties: object properties and data properties. An object property relates two classes. The property can have a domain and a range class, which includes the class and all of it's subclasses. Following on from the previous example, the object property \textit{hasRoom} could have the domain \textbf{House} and the range \textbf{Room}. Specifically, you could represent a cottage having a kitchen with: \textit{``CottageHouse hasRoom KitchenRoom''}. A data property links a class to a literal value, such as an integer, boolean value or string. They can also have a domain class and a range data type (integer, string etc.). For example, the data property \textit{hasNumberOfWindows} could be used to link a \textbf{House} class to an integer value of how many windows the house has. You could represent a bungalow having 3 windows as: \textit{``BungalowHouse hasNumberOfWindows 3''}. 

Both these properties can have many characteristics. These properties are also stored in an object oriented fashion, so if the \textit{hasKitchen} property was a subproperty of \textit{hasRoom}, and it is stated that \textit{``CottageHouse hasKitchen ModernKitchen''}, then the reasoner would be able to infer that \textit{``CottageHouse hasRoom ModernKitchen''}. Properties can be transitive: if \textbf{X} is related to \textbf{Y} via \textit{propertyA}, and \textbf{Y} is related to \textbf{Z} via \textit{propertyA}, then \textbf{X} is related to \textbf{Z} via \textit{propertyA}. An example of this would be the property \textit{isAncestorOf}. They can also be functional. This means that there is at most one object that is related to an object via that property. Therefore, if two objects are related to an object via a functional property, then it will be reasoned that they must be the same object. An example of a functional property would be \textit{hasNationalInsuranceNumber}, because people can only have one national insurance number. Properties can also have inverses. If \textbf{X} is related to \textbf{Y} via \textit{propertyA} and \textit{propertyB} is the opposite of \textit{propertyA}, the \textbf{Y} is related to \textbf{X} via \textit{propertyB}. The domain of \textit{propertyA} will be the range of \textit{propertyB} and the range of \textit{propertyA} will be the domain of \textit{propertyB}. A property can be symmetric. If \textbf{X} is related to \textbf{Y} via \textit{propertyA}, then \textbf{Y} is related to \textbf{X} via \textit{propertyA}. An example of that would be \textit{hasNeighbour}. Properties can also be asymmetric, which means they can never be symmetric. Properties can also be reflexive, meaning they always relate an individual to itself. The mathematical operation \textit{=} would be an example of this, as any number is always equal to itself. They can also be irreflexive, which means an individual can never be related to itself. An example could be \textit{hasFather} - as you cannot be your own father.

\subsection{Defined Classes}

Defined Classes are classes that contain rules. For example, a \textbf{VegetarianDish} could be defined as a dish that contains no \textbf{MeatIngredient}. In an ontology, you would say that a \textbf{VegetarianDish} is a subclass of \textbf{Dish} and a subclass of \textit{``not(containsIngredient some MeatIngredient)''}.

\subsection{Instances}

Instances are just that, an instance of a class. You can have many instances of a class, each with different object properties and data properties. This way, you could create two instances of a bungalow, but with different numbers of bedrooms and different addresses. Instances are useful when you want to have many occurences of a class that are slightly different.

\subsection{Enumerations}

Enumerations are also a concept from object oriented programming that is utilised in ontologies. When a property can only take one of a few possible values, it can be convenient to create an enumeration - which explicitly defines those few possible values. An example would be the seasons, which can only be winter, spring, summer or autumn.

There are other aspects of ontologies that are not used in this project, such as annotations and DL and SPARL querys.

\subsection{Open World Assumption}

Ontologies have an open world assumption, which means that we can't assume that something does not exist, purely because it is not in the ontology. We need to explicitly specify in the ontology that it does not exist. Otherwise, it is assumed as knowledge that is yet to be added to the ontology. In other words, if we haven't said that something is true - we cannot assume it is false, we need to explicitly state that it is false. It is not sufficient to say that a dish contains some ingredients, you also need to state that it contains only these ingredients. Take the example of a \textbf{MargheritaPizza}, which contains the ingredients \textbf{PizzaBaseIngredient}, \textbf{TomatoIngredient}, and \textbf{CheeseIngredient}. Simply stating that a \textbf{MargheritaPizza} \textit{``containsIngredient some PizzaBaseIngredient''}, \textit{``containsIngredient some TomatoIngredient''}, and \textit{``containsIngredient some CheeseIngredient''} would mean that any pizza with these 3 ingredients is classed as a \textbf{MargheritaPizza}. Because of this, a \textbf{MargheritaPizza} instance could still contain a \textbf{MeatIngredient} as long as it had the three required ingredients, and therefore we cannot class it as a \textbf{VegetarianPizza}. It is important to specify that a \textbf{MargheritaPizza} \textit{``containsIngredient only (PizzaBaseIngredient or TomatoIngredient or CheeseIngredient)''} so that we specify only those 3 ingredients can be in a \textbf{MargheritaPizza}. 

\section{Technologies}

I initially used Protégé to familiarise myself with working with ontologies. The user interfaces and the code to connect them to the ontology are written in Java as it has the useful and comprehensive Web Ontology Language (OWL) Application Programming Interface (API) \cite{owl_api}, which can be used to interact with OWL Ontologies. I used Java Swing to create the user interfaces themselves. The project is built using Maven and produces a runnable \textit{.jar} file that should be placed in the same folder as the \textit{.owl} file.

\subsection{Protégé}

Protégé \cite{protege_2023} is a free, open-source software interface for interacting with ontologies. The workspace is customizable and makes it easy to navigate ontologies and the relationships within them. It also supports the querying of ontologies.

I used Protégé throughout my development to monitor my menu ontology. When my user interfaces made changes to the ontology, I used Protégé to ensure the expected changes had been made. I also employed Protégé to help me debug problems, or manually fix the ontology if my system broke it.

\subsection{The OWL API}

The OWL API is a Java API that allows you to create and manage OWL ontologies. It can be installed to a project using maven. I followed the following tutorial \cite{matenzoglu_palmisano_2016} to begin to get to grips with the OWL API, along with the documentation that is available here \cite{owl_api_doc_2023}. I chose to use this API over various Python APIs because I am familiar with Java and find Java much easier to use than Python when working with new, less documented APIs. On top of this, the API has been developed by The University of Manchester, so it would be easier to find someone to answer any questions I had while using it.

\subsection{Java Swing}

Java Swing \cite{java_swing_2020} is a Graphical User Interface (GUI) widget library for Java. It contains many lightweight components that can be utilised and customized easily. It provides a familiar and intuitive aesthetic to components that make users instictively know what to do with them. The library is platform independant, which means GUIs developed using it are portable to many devices.

I chose Java Swing because I was familiar with the various components and believed they would provide an intuitive interface for customers. Because my project does not focus on the aestetics of the system, I was not going to be changing how the components looked. Therefore I wanted a library of components that was already set up to be usable. 

In Java Swing, a JFrame is the window of the application, and it contains JPanels (a view). JPanels have a layout, and you can add many types of components to a JPanel, such as JTextFields which allow the user to enter text, JButtons which display a button to carry out an action, JLists to display arrays of data and JCheckboxes to display a tickbox. A JSlider allows a user to choose a particular value from a set range, and a JOptionPane displays a message in a pop-up window - which is useful for giving informative feedback. You can also add a JPanel to itself to create more complex designs and layouts.

% Local Variables:
% mode: latex
% TeX-master: "report"
% End:
