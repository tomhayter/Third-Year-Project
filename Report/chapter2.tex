\chapter{Background}

\section{Diets}

After suffering from the COVID-19 pandemic, restaurants are keen to get as much business as possible. To do this, they need to cater to all customers and all dietary requirements. To achieve that, they need to easily allow customers to calculate which dishes are suitable for them.

Almost 30\% of adults in the UK have some sort of vegetarian-based diet \cite{vege_2022}, and the percentage is greater in the younger generations than the older ones. With an increasing concern about the environmental, ethical and health impacts of the food that we eat - people are looking at reducing and removing meat from their diets (Flexitarian or Vegetarian), or removing all animal products completely (Vegan).

On top of this, 8\% of children and 6\% of adults will have an allergy \cite{sicherer_sampson_2017}. The most common allergies are cow's milk, eggs, peanuts, soybeans, wheat, fish, shellfish and tree nuts \cite{allergies_west_2023}. Allergic reactions can vary from mild to severe, and therefore, it is important that a restaurant is able to offer allergen information about their dishes. Moreover, while Coeliacs disease is not an allergy but a autoimmune disease, those who suffer from the disease want to avoid foods that contain gluten.

With 63\% of people in the UK stating they have some religion \cite{religion_ons_census_2021}, and 84\% of the population worldwide \cite{hackett_grim_2012}, it is vital to consider religious dietary requirements. I have used this guide \cite{guidance_on_foods_for_religious_faiths_2009} to understand what dietary requirements different religions have. This means that least 45\% of the global population will have a dietary requirement purely based on their religous belief, which makes it essential that they are considered. While some religions simply follow or encourage vegetarianism or veganism (such as Buddhism), others are more complex. Hinduism and Sikhism will specifically not eat beef or beef products. Furthermore, Muslims, Jews, and Rastafarians will not eat pork or pork products, with the former two not eating shellfish either. Therefore, specfic measures should be taken to ensure that these customers can determine which dishes are suitable for them.

In addition to specific ingredients, there are other religious beliefs concerning food. Muslims are only permitted to eat Halal (permissable) foods, or foods that are not Haram (forbidden). Halal meats must come from an animal that has been slaughtered in a specific way according to the Halal Monitoring Committee \cite{halal_monitoring_committee_2018}. The animal must be alive and healthy at the time of slaughter, and after invoking the name of Allah on the animal, at least three of the Trachea, Oesophagus and both Jugular Viens must be severed. In Judaism, followers may only eat Kosher foods \cite{kosher_2023}. This specifies that they must not eat dairy and meat products together, and the two should not be prepared together either to avoid cross-contamination. Meat should also be sourced from an animal that has been slaughtered in a specific way.

Both Halal and Kosher diets do not solely revolve around what ingredients are in a dish, but also how that dish has been prepared. It should also be noted that not all religions are strict. Some diets are stricter than others, so there is not one single catch-all diet for a religion.


\section{Ontologies}

When researching ontologies, I constantly referred to the pizza tutorial \cite{pizza_tutorial_site}. It provides a comprehensive understanding of ontologies and how they work, while also providing examples and a tutorial to follow along with.

An ontology is a knowledge-based way of storing information. They are stored in a \textit{.owl} file, which is similar to an XML. It works in a object oriented kind-of way, where every thing is a class. Ontologies make use of the concept of inheritance, so classes can have subclasses where the subclass \textit{``is a''} superclass. For example, the class \textit{``House''} could be a subclass of \textit{``Building''}, and could have \textit{``Mansion''}, \textit{``Bungalow''} and \textit{``Cottage''} as it's subclasses. This works because a house \textit{``is a''} building and a cottage \textit{``is a''} house. Everything that holds true for a superclass also holds true for all the subclasses. In an ontology, every class is a subclass of \textit{``Thing''}. It is convention to name a subclass with a suffix to make it clear what it is a subclass of (other than when creating a subclass of \textit{``Thing''}). In the previous example, all subclasses of \textit{``House''} would have the suffix \textit{``House''} (e.g. \textit{``CottageHouse''} and \textit{``BungalowHouse''}) to differentiate them from anything else that could have the same name. For example, having one class called \textit{``Cottage''} could lead to ambiguity between the building and the type of cheese - if both happened to be stored in the same ontology. 

Ontologies contain facts, properties and rules, and uses those rules and properties to infer more facts. There is a tool called a reasoner which infers these facts. While many are available, I have used Hermit \cite{hermit} as it is the most up to date.

\subsection{Object and Data Properties}

There are two kinds of properties: object properties and data properties. An object property relates two classes. The property can have a domain and a range class, which includes the class and all of it's subclasses. Following on from the previous example, the object property \textit{``hasRoom''} could have the domain \textit{``House''} and the range \textit{``Room''}. Specifically, you could represent a cottage having a kitchen with: \textit{``CottageHouse hasRoom KitchenRoom''}. A data property links a class to a literal value, such as an integer, boolean value or string. They can also have a domain class and a range data type (integer, string etc.). For example, the data property \textit{``hasNumberOfWindows''} could be used to link a \textit{``House''} class to an integer value of how many windows the house has. You could represent a bungalow having 3 windows as: \textit{``BungalowHouse hasNumberOfWindows 3''}. 

Both these properties can have many characteristics. These properties are also stored in an object oriented fashion, so if the \textit{``hasKitchen''} property was a subproperty of \textit{``hasRoom''}, and it is stated that \textit{CottageHouse hasKitchen ModernKitchen}, then the reasoner would be able to infer that \textit{CottageHouse hasRoom ModernKitchen}. Properties can be transitive: if \textbf{X} is related to \textbf{Y} via \textbf{PropertyA}, and \textbf{Y} is related to \textbf{Z} via \textbf{PropertyA}, then \textbf{X} is related to \textbf{Z} via \textbf{PropertyA}. They can also be functional. This means that there is at most one object that is related to an object via that property. Therefore, if two objects are related to an object via a functional property, then it will be reasoned that they must be the same object. An example of a functional property would be \textit{``hasNationalInsuranceNumber''}, because people can only have one national insurance number. Properties can also have inverses. If \textbf{X} is related to \textbf{Y} via \textbf{PropertyA} and \textbf{PropertyB} is the opposite of \textbf{PropertyA}, the \textbf{Y} is related to \textbf{X} via \textbf{PropertyB}. The domain of \textbf{PropertyA} will be the range of \textbf{PropertyB} and the range of \textbf{PropertyA} will be the domain of \textbf{PropertyB}. A property can be symmetric. If \textbf{X} is related to \textbf{Y} via \textbf{PropertyA}, then \textbf{Y} is related to \textbf{X} via \textbf{PropertyA}. An example of that would be \textit{``hasNeighbour''}. Properties can also be asymmetric, which means they can never be symmetric. Properties can also be reflexive, meaning they always relate an individual to itself. They can also be irreflexive, which means an individual can never be related to itself.

\subsection{Defined Classes}

Defined Classes are classes that contain rules. For example, a \textit{``VegetarianDish''} could be defined as a dish that contains no \textit{``MeatIngredient''}. In an ontology, you would say that a \textit{``VegetarianDish''} is a subclass of \textit{`Dish'} and a subclass of \textit{``not(containsIngredient some MeatIngredient)''}.

\subsection{Instances}

Instances are just that, an instance of a class. You can have many instances of a class, each with different object properties and data properties. This way, you could create two instances of a bungalow, but with different numbers of bedrooms and different addresses. Instances are useful when you want to have many occurences of a class that are slightly different.

\subsection{Enumerations}

Enumerations are also a concept from object oriented programming that is utilised in ontologies. When a property can only take one of a few possible values, it can be convenient to create an enumeration - which explicitly defines those few possible values. An example would be the seasons, which can only be winter, spring, summer or autumn.

There are other aspects of ontologies that are not used in this project, such as annotations and DL and SPARL querys.

\subsection{Open World Assumption}

Ontologies have an open world assumption, so all constraints on classes must be declared. It is not sufficient to say that a dish contains some ingredients, but also that it contains only these ingredients. Otherwise, a dish with those ingredients plus more would be valid. This is important when calculating things like a vegetarian dish. Take the example of a Margherita pizza, which contains a pizza base, tomato sauce and cheese. If the ontology only states that it contains at least these ingredients, then while a Margherita pizza would be classed as a margherita pizza, so would a meat feast pizza that contains those three ingredients plus more. It is for this reason why the reasoner cannot deduce that a margherita pizza is a vegetarian dish, unless the ontology states that a margherita can only contain those three ingredients.

\section{Technologies}

I initially used Protégé to get used to working with ontologies. The user interfaces are written in Java as it has the useful and comprehensive Web Ontology Language (OWL) Application Programming Interface (API) \cite{owl_api}, which can be used to interact with ontologies. I used Java Swing to create the user interfaces themselves. The project is built using Maven and produces a runnable .jar file that should be placed in the same folder as the .owl file.

\subsection{Protégé}

Protégé \cite{protege_2023} is a free, open-source software interface for interacting with ontologies. The workspace is customizable and makes it easy to navigate ontologies and the relationships within them. It also supports the querying of ontologies.

I used Protégé throughout my development to monitor my menu ontology. When my user interfaces made changes to the ontology, I used Protégé to ensure the expected changes had been made to the ontology. I also employed Protégé to help me debug problems, or manually fix the ontology if one of my user interfaces broke it.

\subsection{The OWL API}

The OWL API is a Java API that allows you to create and manage OWL ontologies. It can be installed to a project using maven. I followed the following tutorial \cite{matenzoglu_palmisano_2016} to begin to get to grips with the OWL API, along with the documentation that is available here \cite{owl_api_doc_2023}. I chose to use this API because I am familiar with Java and find it much easier to use than Python when working with new, less documented APIs as it is clear what types are being returned from methods. On top of this, it has been developed by The University of Manchester, so It would be easier to find someone to answer my questions.

\subsection{Java Swing}

Java Swing \cite{java_swing_2020} is a Graphical User Interface (GUI) widget library for Java. It contains many lightweight components that can be utilised and customized easily. It provides a familiar and intuitive aesthetic to components that make users instictively know what to do with them. The library is platform independant, which means GUIs developed using it are portable to many devices.

I chose Java Swing because it has a lot of components already set up that can be used. JFrames are the windows that contain JPanels (a view). JPanels have a layout, and you can add many types of Components to display, such as a JTextField which allows the user to enter text, a JButton which makes actions for the user to take obvious, JLists to display data and JCheckboxes to select specific options. A JSlider can be used to choose a particular value from a set range, and a JOptionPane which displays a message in a pop-up window - which is useful for giving informative feedback. They also allow for clear consistency between objects of similar types.

% Local Variables:
% mode: latex
% TeX-master: "report"
% End:
