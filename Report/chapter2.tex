\chapter{Background}

\section{Diets}

After suffering from the COVID-19 pandemic, restaurants are keen to get as much business as possible. To do this, they need to cater to all customers and all dietary requirements. To achieve that, they need to allow customers to easily deduce which dishes are suitable for them.

Almost 30\% of adults in the UK have some sort of vegetarian-based diet \cite{vege_2022}, and the percentage is greater in the younger generations than the older ones. With increasing concern about the environmental, ethical and health impacts of the food that we eat - people are looking at reducing and removing meat from their diets (flexitarian or vegetarian) or removing all animal products completely (vegan).

On top of this, 8\% of children and 6\% of adults have a food-based allergy \cite{sicherer_sampson_2017}. The most common food allergies are cow's milk, eggs, peanuts, soybeans, wheat, fish, shellfish and tree nuts \cite{allergies_west_2023}. Allergic reactions can vary from mild to severe, and therefore, it is important that restaurants offer allergen information about their dishes. Furthermore, while Coeliac disease is not an allergy but an autoimmune disease, those who suffer from the disease want to avoid foods that contain gluten, which is a similar problem to allergies.

With 63\% of people in the UK \cite{religion_ons_census_2021} and 84\% of the population worldwide \cite{hackett_grim_2012} stating that they have some religion, it is vital to consider religious dietary requirements. I have used this guide \cite{guidance_on_foods_for_religious_faiths_2009} to understand what dietary requirements different religions have. At least 45\% of the global population have a dietary requirement purely based on their religious belief, which makes it essential that they are considered by restaurants. While some religions simply follow or encourage vegetarianism or veganism (such as Buddhism), others are more complex. Hindus and Sikhs do not eat beef or beef products. Furthermore, Muslims, Jews, and Rastafarians do not eat pork or pork products, with the former two not eating shellfish either. Therefore, specific measures should be taken to ensure that these customers can determine which dishes are suitable for them.

In addition to specific ingredients, there are other religious beliefs concerning food. Muslims are only permitted to eat Halal (permissible) foods, or foods that are not Haram (forbidden). Halal meats must come from an animal that has been slaughtered in a specific way according to Islamic Law (Shari'ah) \cite{halal_monitoring_committee_2018}. The animal must be alive and healthy at the time of slaughter and, after invoking the name of Allah on the animal, at least three of the Trachea, Oesophagus and both Jugular Veins must be severed. In Judaism, followers may only eat Kosher foods \cite{kosher_2023} ; foods that conform to \textit{kashrut} (Jewish dietary law). This specifies that they must not eat dairy and meat products together, and the two should not be prepared together either to avoid cross-contamination. Meat should also be sourced from an animal that has been slaughtered in a specific way.

Both Halal and Kosher foods do not solely revolve around what ingredients are in a dish, but also how that dish has been prepared. It should also be noted that not all religions are strict. Some religious followers are stricter with diets than others, so there is not one single catch-all dietary requirement for a religion.


\section{Ontologies}

While researching ontologies, I constantly referred to the \textit{``Pizza Tutorial''} \cite{pizza_tutorial_site}. It provides a comprehensive understanding of Web Ontology Language (OWL) ontologies and how they work, while also providing examples and a tutorial to follow along with. In this section, I will represent classes in bold such as \textbf{ClassA} and properties in italics such as \textit{propertyA}. Class expressions will be represented in quotation marks and italics, such as \textit{``ClassA propertyA ClassB''}

An ontology is a knowledge-based way of storing information. They are stored in a \textit{.owl} file. It works in an object-oriented way, where a thing is a class. Ontologies make use of the concept of inheritance, so classes can have subclasses where the subclass \textit{``is a''} superclass. For example, the class \textbf{House} could be a subclass of \textbf{Building}, and could have \textbf{Mansion}, \textbf{Bungalow} and \textbf{Cottage} as its subclasses. This works because a house \textit{``is a''} building and a cottage \textit{``is a''} house. An implementation of this example in Protégé can be seen in Figure \ref{fig:example_ontology}. Everything that holds true for a class also holds true for all of that class's subclasses. In an ontology, every class is a subclass of \textbf{owl:Thing}. It can be useful to name a subclass with a suffix to make it clear what it is a subclass of. In the previous example, all subclasses of \textbf{House} could have the suffix \textit{``House''} (e.g. \textbf{CottageHouse} and \textbf{BungalowHouse}) to differentiate them from anything else that could have the same name. For example, having one class called \textbf{Cottage} could lead to ambiguity between the building and the type of cheese - if both happened to be stored in the same ontology. 

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=0.30\textwidth]{screenshots/ExampleOntology.png}
    \caption{Example ontology structure}
    \label{fig:example_ontology}
\end{figure}

Ontologies contain facts, properties and axioms, and use those axioms and properties to infer more facts. There is a tool called a reasoner which infers these facts. While many are available, I have used Hermit \cite{hermit} as it is the most up-to-date.

Ontologies are not a common method of storing information. One of the largest ontologies, Yago \cite{suchanek_abiteboul_manolescu_rigaux_rousset_senellart_2011} , is predominantly harnessed for natural language tasks such as question answering, entity recognition and semantic textual analysis \cite{pellissier2020yago}. The common opinion on using ontologies in real-world applications is that they become slow when more expressive reasoning is required \cite{srinivas2009owl, weithoner2007real} due to the need for completeness. If the ontology is kept simple, and the reasoning is fast, I see no reason why OWL ontologies can not be used for real-world applications.

\subsection{Object and Data Properties}

There are two kinds of properties: object properties and data properties. An object property relates two classes. The property can have a domain and a range class, which includes the class and all of its subclasses. Following on from the previous example, the object property \textit{hasRoom} could have the domain \textbf{House} and the range \textbf{Room}. Specifically, you could represent a cottage having a kitchen with: \textit{``CottageHouse hasRoom KitchenRoom''}. A data property links a class to a literal value, such as an integer, boolean value or string. They can also have a domain class and a range data type (integer, string etc.). For example, the data property \textit{hasNumberOfWindows} could be used to link a \textbf{House} class to an integer value of how many windows the house has. You could represent a bungalow having 3 windows as: \textit{``BungalowHouse hasNumberOfWindows 3''}. 

Both these properties can have many characteristics. These properties are also stored in an object-oriented fashion, so if the \textit{hasKitchen} property is a sub-property of \textit{hasRoom}, and it is stated that \textit{``CottageHouse hasKitchen ModernKitchen''}, then the reasoner would be able to infer that \textit{``CottageHouse hasRoom ModernKitchen''}. Properties can be transitive: if \textbf{X} is related to \textbf{Y} via \textit{propertyA}, and \textbf{Y} is related to \textbf{Z} via \textit{propertyA}, then \textbf{X} is related to \textbf{Z} via \textit{propertyA}. An example of this would be the property \textit{isAncestorOf}. They can also be functional. This means that there is at most one entity that is related to an entity via that property. Therefore, if two entities are related to an entity via a functional property, then it will be reasoned that they must be the same entity. An example of a functional property would be the data property \textit{hasNumberOfWindows}, to ensure no house has more than one number of windows. Properties can also have inverses. If \textbf{X} is related to \textbf{Y} via \textit{propertyA} and \textit{propertyB} is the inverse of \textit{propertyA}, the \textbf{Y} is related to \textbf{X} via \textit{propertyB}. The domain of \textit{propertyA} will be the range of \textit{propertyB} and the range of \textit{propertyA} will be the domain of \textit{propertyB}. A property can be symmetric. If \textbf{X} is related to \textbf{Y} via \textit{propertyA}, then \textbf{Y} is related to \textbf{X} via \textit{propertyA}. An example of that would be \textit{hasNeighbour}. Properties can also be asymmetric, which means they can never be symmetric. Additionally, properties can be reflexive, meaning they always relate an individual to itself. The mathematical operation \textit{=} would be an example of this, as any number is always equal to itself. They can also be irreflexive, which means an individual can never be related to itself. An example could be \textit{hasFather} - as you cannot be your own father.

\subsection{Quantifiers}

Two quantifier restrictions are used in this project, existential and universal quantifiers. Existential quantifiers are represented by the keyword ``some'', and require at least one relation for a specific property. For example, dishes that \textit{``hasIngredient some VegetableIngredient''} are equivalent to dishes that contain at least one vegetable. Conversely, universal quantifiers require all relations to be of a specific relation, and are represented by the keyword ``only''. For example, dishes that \textit{``hasIngredient only VegetableIngredient''} are equivalent to dishes that only contain vegetables.

\subsection{Defined Classes}

Defined classes are classes that have constraints defined by axioms. What differentiates a derived class from a normal (primitive) class is that the constraints for a primitive class are necessary, whereas the constraints for a defined class are necessary and sufficient. Necessary axioms can be thought of as ``All members of this class must fulfil these conditions''. Necessary and sufficient axioms can be thought of as ``Anything that meets these conditions is a member of this class''. An example of a derived class is a \textbf{VegetarianDish} could be defined as a dish that contains no \textbf{MeatIngredient}. In an ontology, you would say that a \textbf{VegetarianDish} is a subclass of \textbf{Dish} and a subclass of \textit{``not(containsIngredient some MeatIngredient)''}.

\subsection{Instances}

Instances are just that, an instance of a class. You can have many instances of a class, each with different object properties and data properties. This way, you could create two instances of a bungalow, but with different numbers of bedrooms and different addresses. Instances are useful when you want to have many occurrences of a class that are slightly different.

\subsection{Enumerations}

Enumerations are also a concept from object-oriented programming that is utilised in ontologies. When a property can only take one of a few possible values, it can be convenient to create an enumeration - which explicitly defines those few possible values. An example would be the seasons, which can only be winter, spring, summer or autumn.

There are other aspects of ontologies that are not used in this project, such as annotations and DL and SPARL queries.

\subsection{Open World Assumption}

Ontologies have an open world assumption, which means that we can not assume that something is false, purely because we do not know that it is true. We need to either explicitly specify that it is false, or state things that entail that it is false. Otherwise, it is assumed as knowledge that may yet be added to the ontology. If you want to store the specific ingredients in a dish with no flexibility, it is not sufficient to say that the dish must contain these ingredients, you also need to state that it only contains these ingredients. Take the example of a \textbf{VegetarianPizza}. A \textbf{MargheritaPizza} contains the ingredients \textbf{PizzaBaseIngredient}, \textbf{TomatoIngredient}, and \textbf{CheeseIngredient}. Simply stating that a \textbf{MargheritaPizza} \textit{``containsIngredient some PizzaBaseIngredient''}, \textit{``containsIngredient some TomatoIngredient''}, and \textit{``containsIngredient some CheeseIngredient''} would mean that any pizza with these 3 ingredients is classed as a \textbf{MargheritaPizza}. Because of this, a \textbf{MargheritaPizza} instance could still contain a \textbf{MeatIngredient} as long as it had the three required ingredients, and therefore we cannot class it as a \textbf{VegetarianPizza}. It is important to specify that a \textbf{MargheritaPizza} \textit{``containsIngredient only (PizzaBaseIngredient or TomatoIngredient or CheeseIngredient)''} so that we specify only those 3 ingredients can be in a \textbf{MargheritaPizza}, and it can be classed as vegetarian. 

\section{Technologies}

I initially used Protégé to familiarise myself with working with ontologies. The user interfaces and the code to connect them to the ontology are written in Java as it has the useful and comprehensive OWL Application Programming Interface (API) \cite{owl_api}, which can be used to interact with OWL Ontologies. I used Java Swing to create the user interfaces themselves. The project is built and packaged using Maven \cite{maven} , which produces a runnable \textit{.jar} file that should be placed in the same folder as the \textit{.owl} file.

\subsection{Protégé}

Protégé \cite{protege_2023} is a free, open-source software interface for interacting with ontologies. The workspace is customisable and makes it easy to navigate ontologies and the relationships within them. It also supports the querying of ontologies.

I used Protégé throughout my development to monitor my menu ontology. When my user interfaces made changes to the ontology, I used Protégé to ensure the expected changes had been made. I also employed Protégé to help me debug problems, or manually fix the ontology if the system was not interacting with the ontology as expected.

\subsection{The OWL API}

The OWL API is a Java API that allows you to create and manage OWL ontologies. It can be installed in a project using Maven. I followed the following tutorial \cite{matenzoglu_palmisano_2016} to begin to get to grips with the OWL API, along with the documentation that is available here \cite{owl_api_doc_2023}. I chose to use this API over various Python APIs because I am familiar with Java and find Java much easier to use than Python when working with new, less documented APIs. On top of this, the API has been developed by The University of Manchester, so it would be easier to find someone to answer any questions I had while using it.

\subsection{Java Swing}

Java Swing \cite{java_swing_2020} is a Graphical User Interface (GUI) widget library for Java. It contains many lightweight components that can be utilised and customised easily. It provides a familiar and intuitive aesthetic to components that make users instinctively know what to do with them. The library is platform-independent, which means GUIs developed using it are portable to many devices.

I chose Java Swing because I was familiar with the various components and believed they would provide an intuitive interface for customers. Because my project does not focus on the aesthetics of the system, I was not going to be changing how the components looked. Therefore I wanted a library of components that was already set up to be usable. 

In Java Swing, a JFrame is the window of the application, and it contains JPanels (a view). JPanels have a layout, and you can add many types of components to a JPanel. These components are collectively referred to as JComponents. Examples of JComponents include JTextFields, which allow the user to enter text, JButtons which display a button to carry out an action, JLists to display arrays of data and JCheckboxes to display a tick-box. A JSlider allows a user to choose a particular value from a set range, and a JOptionPane displays a message in a pop-up window - which is useful for giving informative feedback. You can also add a JPanel to itself to create more complex designs and layouts.

% Local Variables:
% mode: latex
% TeX-master: "report"
% End:
